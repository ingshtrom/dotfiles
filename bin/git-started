#!/usr/bin/env bash
#
# Usage: git-workspace-setup
#
# Fork git repo, clone it bare, set up remotes. All for working with worktrees
#
# Requires:
#   - GitHub CLI

# set -x
set -e

red=`tput setaf 1`
green=`tput setaf 2`
yellow=`tput setaf 3`
reset=`tput sgr0`

# repo_namespace=${1}
# repo_name=${2}


echo "${yellow}Here are the current workspace repositories:${reset}"
ls -al "${HOME}/workspace"
echo
echo
echo "${yellow}What is the ${red}namespace${yellow} of the GitHub repository you want to fork?${reset}"
read repo_namespace
echo
echo "${yellow}What is the ${red}name${yellow} of the GitHub repository you want to fork?${reset}"
read repo_name
echo

if [[ "$(pwd)" != "${HOME}/workspace" ]];
then
  cd "${HOME}/workspace"
fi

# 1. fork the repo
# 2. clone --bar the repo
# 3. set up remotes with origin and upstream
# 4. git worktree add main and cd into it
gh repo fork "${repo_namespace}/${repo_name}" --clone=false

git clone --bare "git@github.com:${repo_namespace}/${repo_name}" "${repo_name}"

cd "${repo_name}"

git worktree add main

cd main

git remote remove origin

git remote add origin git@github.com:ingshtrom/${repo_name}.git
git remote add upstream git@github.com:${repo_namespace}/${repo_name}.git

gh repo set-default ${repo_namespace}/${repo_name}

git-ups

echo
echo '----------------------------'
echo
echo "${green}Git Workspace setup!"
echo $reset
echo "name: ${repo_name}"
echo "path: ${HOME}/workspace/${repo_name}"

# # make sure there are no changes to the current branch before attempting to switch
# if ! ( git diff --exit-code > /dev/null 2>&1 && git diff --cached --exit-code > /dev/null 2>&1 )
# then
#   git status
#   echo
#   echo -n $yellow
#   echo '-------------------------------------------------------------------------------------'
#   echo -n $red
#   echo "ðŸ”¥ Cannot sync the main/master branch when there are changes in the current branch"
#   echo -n $green
#   echo 'ðŸ¤” You could always create a new worktree if you need to work on something and leave this code as-is'
#   exit 1
# fi
#
# MAIN_BRANCH='unknown'
# MAIN_REMOTE='unknown'
#
# # if we are not on main/master, then switch to it
# # we already know we do not have changes in our current branch
# branches=$(git branch)
# if echo $branches | grep 'main' 2>&1 > /dev/null; then
#   MAIN_BRANCH='main'
# elif echo $branches | grep 'master' 2>&1 > /dev/null; then
#   MAIN_BRANCH='master'
# fi
#
# if [[ "$MAIN_BRANCH" == "unknown" ]]; then
#   echo "main or master not found in branch listing"
#   exit 1
# fi
#
# remotes=$(git remote -v)
# if echo $remotes | grep 'upstream' 2>&1 > /dev/null;
# then
#   MAIN_REMOTE='upstream'
# elif echo $remotes | grep 'origin' 2>&1 > /dev/null;
# then
#   MAIN_REMOTE='origin'
# fi
#
# if [[ "$MAIN_REMOTE" == "unknown" ]]; then
#   echo "upstream or origin not found in remote listing"
#   exit 1
# fi
#
# COMMIT=$(git log -1 --oneline | sed 's/\n//g' | cut -d' ' -f1)
#
# git fetch $MAIN_REMOTE --tags --quiet
#
# git checkout "${MAIN_BRANCH}" --quiet
# git reset --hard "${MAIN_REMOTE}/${MAIN_BRANCH}" --quiet
#
# # make sure our forked main/master is up to date with the latest changes too
# if [[ "$MAIN_REMOTE" == "upstream" ]]; then
#   git push --force origin "$MAIN_BRANCH" --quiet
# else
#   echo "not pushing because we are not on a fork"
# fi
#
# git --no-pager log --color --oneline "${COMMIT}..${MAIN_REMOTE}/${MAIN_BRANCH}" --oneline
#  the end!
