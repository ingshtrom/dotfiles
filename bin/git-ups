#!/usr/bin/env bash
#
# Usage: git-ups
#
# Like git fetch && git merge but show a short and sexy log of changes
# immediately after merging (git-ups)
#
# Inspired by Kyle Neath's `git up' alias:
# http://gist.github.com/249223

# set -x

red=`tput setaf 1`
green=`tput setaf 2`
yellow=`tput setaf 3`
reset=`tput sgr0`



MAIN_WORKTREE='unknown'
MAIN_REMOTE='unknown'

# we already know we do not have changes in our current branch
worktrees=$(git worktree list)
if echo $worktrees | grep '\[main\]' 2>&1 > /dev/null; then
  MAIN_WORKTREE='main'
elif echo $worktrees | grep '\[master\]' 2>&1 > /dev/null; then
  MAIN_WORKTREE='master'
fi

if [[ "$MAIN_WORKTREE" == "unknown" ]]; then
  echo "main or master not found in branch listing"
  exit 1
fi

remotes=$(git remote -v)
if echo $remotes | grep 'upstream' 2>&1 > /dev/null;
then
  MAIN_REMOTE='upstream'
elif echo $remotes | grep 'origin' 2>&1 > /dev/null;
then
  MAIN_REMOTE='origin'
fi

if [[ "$MAIN_REMOTE" == "unknown" ]]; then
  echo "upstream or origin not found in remote listing"
  exit 1
fi

COMMIT=$(git log -1 --oneline | sed 's/\n//g' | cut -d' ' -f1)

git fetch $MAIN_REMOTE --tags --quiet

# if we are not on main/master, then switch to the worktree
cd $(git worktree list | grep '\[main\]' | cut -d' ' -f1) 

# make sure our forked main/master is up to date with the latest changes too
if [[ "$MAIN_REMOTE" == "upstream" ]]; then
  git push --force origin "$MAIN_WORKTREE" --quiet
else
  echo "not pushing because we are not on a fork"
fi

git --no-pager log --color --oneline "${COMMIT}..${MAIN_REMOTE}/${MAIN_WORKTREE}" --oneline

